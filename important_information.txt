GA
https://qiita.com/kimisyo/items/2a1fc6a28b389f3e0561
評価についてはcreator.create("FitnessMax", base.Fitness, weights=(-1.0, 1.0))で指定している。ソース中の肝ともいえる部分である。
これは評価関数 get_fitnessからの戻り値(特徴数、スコア）の評価方法を設定しており、-1は低い方をよく評価し、1は高い方を評価するという意味である。
つまり特徴数が少なく精度が高いほどを優秀な遺伝子として残していくわけである（ここでようやく遺伝的アルゴリズムっぽい単語が登場）。
このことが理解できれば、このアルゴリズムを別の問題にも適用できるだろう。

最良個体が出ない原因の可能性（ChatGPTより）
特定の領域に制限される:
A=0.7, B=0.3のようにAを優先すると、最適解として求めるべき解が、Aの値が極端に低い（良い）範囲内に限定されるため、
探索空間内で他の部分がほとんど無視される形になります。Aの値が低くなる領域は、Bを含む他の目的関数が必ずしも理想的な値をとるとは限りません。
したがって、探索が集中する範囲が狭くなり、その狭い範囲内で多目的な条件（Bの値も適度に低い）を満たす解を見つけにくくなります。

エリート保存戦略を用いたら最良個体なくなる問題解決できそう？


交叉率と突然変異率
交叉率 100パーセント
突然変異率　20パーセント

滞在時間
はこぶらの元町散策コースが所要時間2~3時間でそのうち約30分の徒歩移動（スタート地点は最寄りの市電駅）
→２時間の観光で30分の移動が主流とする
函館駅から金森周辺まで往復約50分
比を使う

例：観光時間が5時間の場合
観光時間120分：移動30分＝観光時間(300 - 50)分：移動x分
x分に駅からの往復時間を足したのが理想の移動時間a
x + 50(駅からの往復移動時間) = a




[[58, 27, 23, 45, 55, 56, 1, 54, 17, 47, 51, 52, 36, 58], 361, 96, 87]
[[58, 53, 56, 31, 17, 1, 45, 51, 54, 55, 27, 47, 58], 353, 118, 77]



def func(a, b, c=3):
    print a, b, c

tools = Toolbox()
tools.register("myFunc", func, 2, c=4) # a = 2，bが（）に入力する値，cに4が代入
tools.myFunc(3)
>>2 3 4

